#!/usr/bin/env python
# coding: utf-8

# ## posteriors_jit.py
# Author: Robert Ietswaart
# Date: 20210623
# License: BSD2.  
# Python v3.7.4 
# 
# Subcellular Timelapse Seq: Bayesian framework to fit time scales (Mean, MAP, 95%CIs) 
# using observed new to total ratio from GRAND-SLAM of the various subcellular RNA fractions
# See Notebook N7p181-186, 196-200, N8p(-4)-2, p9 and p96-109 for math derivations

import numpy as np
from scipy.special import beta
from numba import jit, float64, int32
from numba.core import types
from numba.typed import Dict

@jit(float64(float64, float64, float64), nopython=True) #NumbaWarning: Cannot cache compile: when you include cache=True
def beta_pdf(x, a, b):
    """defined on domain of x: [0,1]
    function structure as in scipy.stats.beta: 
    https://github.com/scipy/scipy/blob/v1.7.0/scipy/stats/_boost/include/func_defs.hpp
    https://www.boost.org/doc/libs/1_61_0/boost/math/distributions/beta.hpp
    
    Gaussian approximations in case of numerical underflow for beta function with large a ,b:
    https://stats.stackexchange.com/questions/2066/how-can-i-numerically-approximate-values-for-a-beta-distribution-with-large-al
    """
    if (x >= 0) and (x <= 1): 
        if (x == 1) and (b < 1):
            return np.inf
        elif (x == 0) and (a < 1):
            return np.inf
        _beta = beta(a, b)
        if _beta > 0:
            return x**(a - 1) * (1 - x)**(b - 1) / _beta
        else:
            #normal distribution approximation because of numerical underflow
            mu = a * (a + b)**(-1)
            sig = np.sqrt(a * b * ((a + b)**(2) * (1 + a + b))**(-1))
            return np.exp(-0.5 * ((x - mu) / sig)**(2)) * (sig * np.sqrt(2 * np.pi))**(-1) 
    else:
        return 0    

#NB: NTR needs to be numba.typed.Dict and TC_TYPES_gene generated by calling fit.get_tc_types_for_gene_jit()
@jit(float64(int32, float64, int32[:], types.DictType(types.unicode_type, float64[:])), nopython=True) 
def get_beta_pdf(i, lam, TC_TYPES_gene, NTR):        
    if len(TC_TYPES_gene) == 1:
        if TC_TYPES_gene[0] == 1:
            tc = 'top1000'
        else:
            tc = 'bottom500'
        alpha_g_t = NTR[tc+'alpha'][i]
        beta_g_t = NTR[tc+'beta'][i]
        beta_pdf_g = beta_pdf(lam, alpha_g_t, beta_g_t)
    else:
        tc_up = 'top1000'
        tc_lo = 'bottom500'
        alpha_g_t_up = NTR[tc_up+'alpha'][i]
        beta_g_t_up = NTR[tc_up+'beta'][i]
        alpha_g_t_lo = NTR[tc_lo+'alpha'][i]
        beta_g_t_lo = NTR[tc_lo+'beta'][i]
        beta_pdf_g = (beta_pdf(lam, alpha_g_t_up, beta_g_t_up) + \
                      beta_pdf(lam, alpha_g_t_lo, beta_g_t_lo)) / 2
    return beta_pdf_g


#NB: NTR needs to be numba.typed.Dict and TC_TYPES_gene generated by calling fit.get_tc_types_for_gene_jit()
@jit(types.DictType(types.unicode_type, float64[:])(int32[:], types.DictType(types.unicode_type, float64[:]), int32), nopython=True) 
def ntr_increased_var(TC_TYPES_gene, NTR, vs):
    if len(TC_TYPES_gene) == 1:
        if TC_TYPES_gene[0] == 1:
            TC = ['top1000']
        else:
            TC = ['bottom500']
    else:
        TC = ['top1000', 'bottom500']
    N_times = NTR[TC[0]+'alpha'].shape[0]
#     print(N_times)
    for tc in TC:
        for i in range(N_times):
            a = NTR[tc+'alpha'][i]
            b = NTR[tc+'beta'][i]
            a_new = a * (1 + a + b - vs) / (vs * (a + b))
            b_new = b * a_new / a 
            NTR[tc+'alpha'][i] = a_new
            NTR[tc+'beta'][i] = b_new
    return NTR

    
@jit(float64(float64, float64), nopython=True, cache=True)
def dlam_1var_da(a, t):
    """ Derivative of Lambda with respect to (only) var a at t
        t: time point (float)  
        a: rate a in domain [0,inf)
        der: derivative, function on a domain
    """
    der = t * np.exp(- a * t)
    return der

@jit(float64(float64, float64, float64), nopython=True, cache=True)
def dlam_2var_db(a, b, t):
    """ Derivative of Lambda, function of two rate variables (a,b) with respect to var b at t
        t: time point (float)  
        a: rate a in domain [0,inf)
        b: rate b in domain [0,inf)
        der: derivative (np.array), function on (a,b) domain
    """
    eps = 1e-16
    if np.absolute(a - b) <= eps:
        der = b * (t**2) * np.exp(-b * t)
    else:
        der = (a * t * (a - b) - a) * (a - b)**(-2) * np.exp(- b * t) + \
            a * (a - b)**(-2) * np.exp(- a * t)
    return der

@jit(float64(float64, float64), nopython=True, cache=True)
def dlam_chr_dkR(kR, t):
    """ Derivative of Lambda with respect to kR at t
        t: time point (float)  
        kR: chromatin residence (Release) rate
        der: derivative (np.array), function on k domain 
    """
    der = dlam_1var_da(kR, t)
    return der

@jit(float64(float64, float64), nopython=True, cache=True)
def dlam_nuc_dkNR(kNR, t):
    """ Derivative of Lambda with respect to kNR at t
        t: time point (float) 
        kNR: Nuclear Residence rate
        der: derivative (np.array), function on k domain 
    """
    der = dlam_1var_da(kNR, t)
    return der

@jit(float64(float64, float64, float64), nopython=True, cache=True)
def dlam_cyto_from_nuc_dkD(kNR, kD, t):
    """ Derivative of Lambda with respect to kD (from_nuc) at t
        t: time point (float)  
        kNR: Nuclear residence rate
        kD: Cytoplasmic residence rate
        der: derivative (np.array), function on k domain
    """
    der = dlam_2var_db(kNR, kD, t)
    return der

@jit(float64(float64, float64, float64, float64), nopython=True, cache=True)
def dlam_poly_from_nuc_dkL(e, d, l, t):
    """ Derivative of Lambda with respect to kR at t
        t: time point (float) 
        e: Nuclear Residence rate
        l: transition rate from cytoplasmic into polysome fraction
        d: cytoplasmic residence (Degradation) rate
        der: derivative (np.array), function on k domain
    """
    eps = 1e-16 
    c = d + l
    if np.absolute(d - e) <= eps or np.absolute(c - e) <= eps: 
        der = 0 #limit approximation
    else:
        der = -e * d / (l**2 * (d - e)) * np.exp(-d * t) + \
            e * d / ((c - e)**2 * (d - e)) * np.exp(-e * t) + \
            e * d * (l * (c - e))**(-1) * (l**(-1) + (c - e)**(-1) + t) * np.exp(-c * t)
    return der

@jit(float64(float64, float64), nopython=True, cache=True)
def dlam_total_dkDtot(kDtot, t):
    """ Derivative of Lambda with respect to kDtot at t
        t: time point (float)
        kDtot: Cellular residence (Total Degradation) rate
        der: derivative (np.array), function on k domain
    """
    der = dlam_1var_da(kDtot, t)
    return der

# #Nuclear degradation model
@jit(float64(float64, float64, float64, float64), nopython=True, cache=True)
def dlam_total_from_nucdeg_dkE(a, kD, kE, t):
    """ Derivative of Lambda with respect to kE at t
        t: time point (float) 
        kN: nuclear degradation rate
        kE: nuclear export rate
        a: kN + kE
        kD: cytoplasmic residence (degradation) rate
        der: derivative (np.array), function on k domain
    """
    eps = 1e-16
    if np.absolute(a - kD) <= eps:
        der = (kD + kE)**(-2) * a * kD * t * np.exp(-a * t)#exact limit a -> kD
    else:
        dPsi = a * kD * ((kD + kE)**(2) * (a - kD))**(-1)
        der = dPsi * (np.exp(-a * t) - np.exp(-kD * t))
    return der


#Determinants of jacobians for posterior change of variable calculation
@jit(float64(float64, float64), nopython=True, cache=True)
def det_jac_chr(kR, t):
    return dlam_chr_dkR(kR, t)

@jit(float64(float64, float64), nopython=True, cache=True)
def det_jac_nuc(a, t):
    return dlam_nuc_dkNR(a, t)
    
@jit(float64(float64, float64, float64), nopython=True, cache=True)
def det_jac_cyto_from_nuc(a, kD, t):
    det = np.absolute(dlam_nuc_dkNR(a, t) * dlam_cyto_from_nuc_dkD(a, kD, t))
    return det

@jit(float64(float64, float64, float64, float64), nopython=True, cache=True)
def det_jac_poly_from_nuc(kNR, kD, kL, t):
    det = np.absolute(dlam_nuc_dkNR(kNR, t) * dlam_cyto_from_nuc_dkD(kNR, kD, t) * dlam_poly_from_nuc_dkL(kNR, kD, kL, t))
    return det

@jit(float64(float64, float64), nopython=True, cache=True)
def det_jac_total_one_step(kDtot, t):
    return dlam_total_dkDtot(kDtot, t)

@jit(float64(float64, float64, float64, float64), nopython=True, cache=True)
def det_jac_total_from_nucdeg(a, kD, kE, t):
    det = np.absolute(dlam_nuc_dkNR(a, t) * dlam_cyto_from_nuc_dkD(a, kD, t) * dlam_total_from_nucdeg_dkE(a, kD, kE, t))
    return det